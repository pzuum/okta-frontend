export class OAuth {
    /** Before sending requests use this to generate a codeVerifier that will work to make sure that the request is safe
     * this will be used again when requesting the token */
     
    static generateCodeVerifier() {
        const codeVerifier = window.btoa(window.crypto.getRandomValues(new Uint8Array(32)).toString());

        return codeVerifier;

    }

    /** Before sending requests use this to generate a codeChallenge based on the code verifier that will work to make sure that the request is safe
     * @param {string} codeVerifier - code verifier generated by the generateCodeVerifier function
     * @example https://{baseurl}/{provider}/?code_challenge={codeChallenge}...
     */
    static async generateCodeChallenge(codeVerifier: string) {
        const codeChallenge = window.crypto.subtle.digest('SHA-256', new TextEncoder().encode(codeVerifier)).then((buffer) => {
            return window.btoa(String.fromCharCode(...new Uint8Array(buffer)));
        });


        return codeChallenge;

    }

    

    /** before sending requests use this to generate a state value and send alongside with the redirect for all Oauth providers in the query params
     * @example https://{baseurl}/{provider}/?state={stateValue}...
    */
    static generateState() {
        const state = window.btoa(window.crypto.getRandomValues(new Uint8Array(32)).toString());

        return state;

    }
    

    /** compare when trading information from backend, store it in the browser storage via local or session storage 
    /* @param {string} state - state from the the browser */
   
    static async validateState(state: string) {
        const urlParams = new URLSearchParams(window.location.search);

        const stateParam = urlParams.get('state');

        if (stateParam !== state) {
            return false;
        }

       

        return true;

    }
}